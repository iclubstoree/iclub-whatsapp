// ============================================================================
// SISTEMA DE IA MELHORADO - CENTROS DE CUSTO + CLASSIFICA√á√ÉO DE STATUS
// ============================================================================

// Vari√°veis para controle de cria√ß√£o de categorias
let aguardandoCriacaoCategoria = false;
let saidaPendenteCategoria = null;
let categoriaParaCriar = null;

// ============================================================================
// PROCESSAMENTO DE MENSAGEM IA MELHORADO
// ============================================================================

async function processarMensagemIA(mensagem) {
  try {
    console.log('üß† Processando:', mensagem);
    
    // Se est√° aguardando cria√ß√£o de categoria
    if (aguardandoCriacaoCategoria) {
      await processarCriacaoCategoria(mensagem);
      return;
    }
    
    const resultado = interpretarMensagemIA(mensagem);
    esconderTyping();
    
    if (!resultado.sucesso) {
      const erro = `‚ùå ${resultado.erro}

üí° Exemplos v√°lidos:
‚Ä¢ "Paguei 500 de aluguel hoje"
‚Ä¢ "Venceu 200 de energia ontem"  
‚Ä¢ "Preciso pagar 300 de internet dia 15"
‚Ä¢ "Lan√ßar 150 de material dia 20"`;
      
      adicionarMensagemChat('system', erro);
      return;
    }
    
    // Verificar se categoria existe
    const categoriaExiste = categorias.includes(resultado.categoria);
    
    if (!categoriaExiste && resultado.categoria !== 'Outros') {
      await solicitarCriacaoCategoria(resultado, mensagem);
      return;
    }
    
    const validacao = validarInformacoesObrigatorias(resultado, mensagem);
    
    if (!validacao.valido) {
      await solicitarInformacoesFaltantes(validacao, resultado, mensagem);
      return;
    }
    
    const lojaMencionada = detectarLojaNaMensagem(mensagem);
    
    if (lojaMencionada) {
      const saidaData = criarDadosSaida(resultado, lojaMencionada);
      await finalizarAdicaoSaida(saidaData);
    } else {
      await solicitarSelecaoLoja(resultado);
    }
    
  } catch (error) {
    console.error('‚ùå Erro processamento:', error);
    esconderTyping();
    adicionarMensagemChat('system', '‚ùå Erro ao processar. Tente novamente.');
  }
}

// ============================================================================
// SISTEMA DE CRIA√á√ÉO DE CATEGORIAS
// ============================================================================

async function solicitarCriacaoCategoria(resultado, mensagem) {
  categoriaParaCriar = resultado.categoria;
  saidaPendenteCategoria = resultado;
  aguardandoCriacaoCategoria = true;
  
  const pergunta = `üè∑Ô∏è N√£o encontrei o centro de custo "${resultado.categoria}".

Deseja criar este novo centro de custo?

Digite "sim" para criar ou "n√£o" para cancelar.`;
  
  adicionarMensagemChat('system', pergunta);
}

async function processarCriacaoCategoria(resposta) {
  adicionarMensagemChat('user', resposta);
  
  const respostaLower = resposta.toLowerCase().trim();
  
  if (respostaLower === 'sim' || respostaLower === 's' || respostaLower === 'ok') {
    // Criar nova categoria
    categorias.push(categoriaParaCriar);
    salvarDadosLocal();
    atualizarInterfaceCompleta();
    
    adicionarMensagemChat('system', `‚úÖ Centro de custo "${categoriaParaCriar}" criado com sucesso!`);
    
    // Continuar com a sa√≠da
    const validacao = validarInformacoesObrigatorias(saidaPendenteCategoria, '');
    
    if (!validacao.valido) {
      await solicitarInformacoesFaltantes(validacao, saidaPendenteCategoria, '');
    } else {
      await solicitarSelecaoLoja(saidaPendenteCategoria);
    }
    
  } else {
    adicionarMensagemChat('system', '‚ùå Cria√ß√£o de centro de custo cancelada. Tente novamente com uma categoria existente.');
  }
  
  // Resetar vari√°veis
  aguardandoCriacaoCategoria = false;
  saidaPendenteCategoria = null;
  categoriaParaCriar = null;
  
  const sendBtn = document.getElementById('chatSendBtn');
  if (sendBtn) sendBtn.disabled = false;
}

// ============================================================================
// INTERPRETA√á√ÉO DE MENSAGEM COM CLASSIFICA√á√ÉO DE STATUS
// ============================================================================

function interpretarMensagemIA(mensagem) {
  try {
    const msgOriginal = mensagem.trim();
    const msgLower = mensagem.toLowerCase().trim();
    
    console.log('üß† IA analisando:', msgLower.substring(0, 50));

    // Buscar treinamentos
    const treinamentoNatural = buscarTreinamentoNatural(msgLower);
    const treinamentoEncontrado = buscarTreinamento(msgLower);
    
    if (treinamentoEncontrado) {
      console.log('üéì Usando treinamento manual:', treinamentoEncontrado);
      return {
        sucesso: true,
        categoria: treinamentoEncontrado.categoria,
        valor: treinamentoEncontrado.valor,
        data: new Date().toISOString().split('T')[0],
        descricao: treinamentoEncontrado.categoria,
        pago: detectarStatusPagamento(msgLower),
        recorrente: detectarRecorrencia(msgLower).recorrente,
        tipoRecorrencia: detectarRecorrencia(msgLower).tipo,
        statusSaida: detectarStatusSaida(msgLower),
        fonte: 'treinamento'
      };
    }

    // Padr√µes de reconhecimento
    const padroes = {
      valor: /(?:r\$?\s*)?(\d{1,3}(?:[.,]\d{3})*(?:[.,]\d{2})?|\d+)\s*(?:reais?|real|pila|conto|pau|dinheiro)?/i,
      
      // Datas espec√≠ficas
      dataHoje: /\b(?:hoje|hj|agora)\b/i,
      dataOntem: /\b(?:ontem|onte)\b/i,
      dataAmanha: /\b(?:amanh√£|amanha|tomorrow)\b/i,
      dataEspecifica: /(?:dia|para\s+dia|no\s+dia|em)\s+(\d{1,2})(?:\/(\d{1,2}))?/i,
      
      // Status de sa√≠da - NOVO
      saidaVencida: /\b(?:venceu|vencido|atrasou|atrasado|atrasada|vencida)\b/i,
      saidaFutura: /\b(?:pagar|lan√ßar|adicionar|programar|agendar)\s+(?:pra|para|no|em|dia)/i,
      saidaFuturaSimples: /\b(?:preciso\s+pagar|vou\s+pagar|tem\s+que\s+pagar|devo\s+pagar)\b/i,
      
      // A√ß√µes tradicionais
      acoesPago: /\b(?:pague[i]?|gaste[i]?|compre[i]?|pago|pagou|gastou|comprou|sa√≠da|despesa|d√©bito|desembolsei?)\b/i,
      acoesNaoPago: /\b(?:devo|deve|preciso\s+pagar|vou\s+pagar|pendente|conta\s+para\s+pagar|a\s+pagar|fatura|boleto)\b/i,
      
      // Recorr√™ncia - apenas se mencionada
      recorrente: /\b(?:recorrente|recorr√™ncia|mensal|todo\s+m√™s|mensalmente|fixo|sempre|mensalidade|repetir)\b/i,
      semanal: /\b(?:semanal|toda\s+semana|semanalmente|por\s+semana)\b/i,
      diario: /\b(?:di√°rio|diario|todo\s+dia|diariamente|por\s+dia)\b/i,
      anual: /\b(?:anual|todo\s+ano|anualmente|por\s+ano|anuidade)\b/i
    };

    // Categorias IA (expandidas)
    const categoriasIA = {
      'Aluguel': { regex: /\b(?:aluguel|aluguer|rent|loca√ß√£o|arrendamento)\b/i, confianca: 0.95 },
      'Energia': { regex: /\b(?:energia|luz|el√©trica|eletricidade|conta\s+de\s+luz|enel|cpfl|cemig)\b/i, confianca: 0.9 },
      'Internet': { regex: /\b(?:internet|wifi|banda\s+larga|provedor|vivo\s+fibra|claro\s+net|tim\s+live)\b/i, confianca: 0.9 },
      '√Ågua': { regex: /\b(?:√°gua|agua|saneamento|conta\s+de\s+√°gua|sabesp|cedae|sanepar)\b/i, confianca: 0.9 },
      'Combust√≠vel': { regex: /\b(?:combust√≠vel|gasolina|etanol|diesel|posto|abasteci|√°lcool|combustivel|gas)\b/i, confianca: 0.9 },
      'Material': { regex: /\b(?:material|escrit√≥rio|papelaria|equipamento|ferramenta|suprimento)\b/i, confianca: 0.8 },
      'Transporte': { regex: /\b(?:transporte|uber|taxi|√¥nibus|onibus|metr√¥|metro|passagem|viagem|corrida)\b/i, confianca: 0.85 },
      'Alimenta√ß√£o': { regex: /\b(?:alimenta√ß√£o|comida|mercado|supermercado|restaurante|lanche|caf√©|delivery)\b/i, confianca: 0.8 },
      'Marketing': { regex: /\b(?:marketing|publicidade|an√∫ncio|anuncio|propaganda|google\s+ads|facebook\s+ads)\b/i, confianca: 0.8 },
      'Sa√∫de': { regex: /\b(?:sa√∫de|saude|m√©dico|medico|hospital|farm√°cia|farmacia|rem√©dio|remedio)\b/i, confianca: 0.85 }
    };

    // STEP 1: Extrair valor
    const matchValor = msgLower.match(padroes.valor);
    if (!matchValor) {
      return { sucesso: false, erro: "N√£o consegui identificar o valor na mensagem" };
    }
    
    const valor = processarValor(matchValor[1]);
    if (isNaN(valor) || valor <= 0) {
      return { sucesso: false, erro: `Valor inv√°lido: ${matchValor[1]}` };
    }

    // STEP 2: Detectar STATUS da sa√≠da (NOVO)
    const statusSaida = detectarStatusSaida(msgLower);
    
    // STEP 3: Extrair/calcular data baseada no status
    let data = calcularDataPorStatus(msgLower, statusSaida, padroes);
    
    // STEP 4: Identificar categoria
    let melhorCategoria = treinamentoNatural ? treinamentoNatural.categoria : "Outros";
    let maiorConfianca = treinamentoNatural ? 0.95 : 0;
    
    for (const [categoria, config] of Object.entries(categoriasIA)) {
      if (config.regex.test(msgLower)) {
        if (config.confianca > maiorConfianca) {
          melhorCategoria = categoria;
          maiorConfianca = config.confianca;
        }
      }
    }

    // STEP 5: Determinar status de pagamento baseado no status da sa√≠da
    let pago = "Sim"; // Default
    
    if (statusSaida === 'vencida') {
      pago = "N√£o"; // Sa√≠da vencida = n√£o paga
    } else if (statusSaida === 'futura') {
      pago = "N√£o"; // Sa√≠da futura = n√£o paga ainda
    } else if (padroes.acoesNaoPago.test(msgLower)) {
      pago = "N√£o";
    } else if (padroes.acoesPago.test(msgLower)) {
      pago = "Sim";
    }

    // STEP 6: Identificar recorr√™ncia (apenas se mencionada)
    const recorrencia = detectarRecorrencia(msgLower);

    // STEP 7: Gerar descri√ß√£o
    let descricao = melhorCategoria;
    if (statusSaida === 'vencida') {
      descricao = `${melhorCategoria} (Vencida)`;
    } else if (statusSaida === 'futura') {
      descricao = `${melhorCategoria} (Agendada)`;
    }

    const resultado = {
      sucesso: true,
      categoria: melhorCategoria,
      valor: valor,
      data: data,
      descricao: descricao,
      pago: pago,
      recorrente: recorrencia.recorrente,
      tipoRecorrencia: recorrencia.tipo,
      statusSaida: statusSaida
    };

    console.log('üéØ Resultado IA:', resultado);
    return resultado;
    
  } catch (error) {
    console.error('‚ùå Erro IA:', error);
    return { sucesso: false, erro: `Erro no processamento: ${error.message}` };
  }
}

// ============================================================================
// FUN√á√ïES AUXILIARES PARA CLASSIFICA√á√ÉO
// ============================================================================

function detectarStatusSaida(mensagem) {
  const padroes = {
    vencida: /\b(?:venceu|vencido|atrasou|atrasado|atrasada|vencida)\b/i,
    futura: /\b(?:pagar|lan√ßar|adicionar|programar|agendar)\s+(?:pra|para|no|em|dia)|(?:preciso\s+pagar|vou\s+pagar|tem\s+que\s+pagar|devo\s+pagar)\b/i
  };
  
  if (padroes.vencida.test(mensagem)) {
    return 'vencida';
  } else if (padroes.futura.test(mensagem)) {
    return 'futura';
  }
  
  return 'atual'; // Default para sa√≠das normais
}

function calcularDataPorStatus(mensagem, statusSaida, padroes) {
  const hoje = new Date();
  let data = hoje.toISOString().split('T')[0]; // Default: hoje
  
  // Verificar datas espec√≠ficas primeiro
  const matchDataEspecifica = mensagem.match(padroes.dataEspecifica);
  if (matchDataEspecifica) {
    const dia = parseInt(matchDataEspecifica[1]);
    const mes = matchDataEspecifica[2] ? parseInt(matchDataEspecifica[2]) : hoje.getMonth() + 1;
    const ano = hoje.getFullYear();
    
    const dataEspecifica = new Date(ano, mes - 1, dia);
    data = dataEspecifica.toISOString().split('T')[0];
  }
  // Verificar padr√µes de data relativa
  else if (padroes.dataOntem.test(mensagem)) {
    const ontem = new Date(hoje);
    ontem.setDate(ontem.getDate() - 1);
    data = ontem.toISOString().split('T')[0];
  } else if (padroes.dataAmanha.test(mensagem)) {
    const amanha = new Date(hoje);
    amanha.setDate(amanha.getDate() + 1);
    data = amanha.toISOString().split('T')[0];
  }
  // Ajustar baseado no status se n√£o h√° data espec√≠fica
  else {
    if (statusSaida === 'vencida') {
      // Se √© vencida mas n√£o tem data espec√≠fica, assumir ontem
      const ontem = new Date(hoje);
      ontem.setDate(ontem.getDate() - 1);
      data = ontem.toISOString().split('T')[0];
    } else if (statusSaida === 'futura') {
      // Se √© futura mas n√£o tem data espec√≠fica, assumir pr√≥xima semana
      const proximaSemana = new Date(hoje);
      proximaSemana.setDate(proximaSemana.getDate() + 7);
      data = proximaSemana.toISOString().split('T')[0];
    }
  }
  
  return data;
}

function detectarRecorrencia(mensagem) {
  const padroes = {
    mensal: /\b(?:recorrente|recorr√™ncia|mensal|todo\s+m√™s|mensalmente|fixo|sempre|mensalidade|repetir)\b/i,
    semanal: /\b(?:semanal|toda\s+semana|semanalmente|por\s+semana)\b/i,
    diario: /\b(?:di√°rio|diario|todo\s+dia|diariamente|por\s+dia)\b/i,
    anual: /\b(?:anual|todo\s+ano|anualmente|por\s+ano|anuidade)\b/i
  };
  
  if (padroes.mensal.test(mensagem)) {
    return { recorrente: "Sim", tipo: "Mensal" };
  } else if (padroes.semanal.test(mensagem)) {
    return { recorrente: "Sim", tipo: "Semanal" };
  } else if (padroes.diario.test(mensagem)) {
    return { recorrente: "Sim", tipo: "Di√°ria" };
  } else if (padroes.anual.test(mensagem)) {
    return { recorrente: "Sim", tipo: "Anual" };
  }
  
  return { recorrente: "N√£o", tipo: null };
}

function processarValor(valorTexto) {
  // Se √© um n√∫mero simples >= 10, considerar como valor direto
  if (/^\d+$/.test(valorTexto)) {
    const numeroSimples = parseInt(valorTexto);
    if (numeroSimples >= 10) {
      return numeroSimples;
    }
  }
  
  // Processar valores com formata√ß√£o
  if (valorTexto.includes('.') && valorTexto.includes(',')) {
    // Ponto como milhares, v√≠rgula como decimal
    valorTexto = valorTexto.replace(/\./g, '').replace(',', '.');
  } else if (valorTexto.includes(',') && valorTexto.split(',')[1]?.length === 2) {
    // V√≠rgula como decimal
    valorTexto = valorTexto.replace(/\./g, '').replace(',', '.');
  } else if (valorTexto.includes('.') && valorTexto.split('.')[1]?.length === 2) {
    // Ponto como decimal
    // J√° est√° correto
  } else if (valorTexto.includes(',')) {
    // V√≠rgula como decimal
    valorTexto = valorTexto.replace(',', '.');
  } else if (valorTexto.includes('.') && valorTexto.split('.')[1]?.length > 2) {
    // Ponto como milhares
    valorTexto = valorTexto.replace(/\./g, '');
  }
  
  return parseFloat(valorTexto);
}

// ============================================================================
// CRIA√á√ÉO DE DADOS DA SA√çDA ATUALIZADA
// ============================================================================

function criarDadosSaida(resultado, loja) {
  return {
    id: Date.now() + Math.random() * 1000,
    loja: loja,
    categoria: resultado.categoria,
    descricao: resultado.descricao,
    valor: resultado.valor,
    data: resultado.data,
    recorrente: resultado.recorrente || "N√£o",
    tipoRecorrencia: resultado.tipoRecorrencia || null,
    pago: resultado.pago,
    statusSaida: resultado.statusSaida || 'atual',
    origem: 'chat',
    timestamp: new Date(),
    dataProcessamento: new Date().toISOString()
  };
}

// ============================================================================
// RESPOSTA MELHORADA DO CHAT
// ============================================================================

function gerarRespostaChat(saida) {
  const dataFormatada = new Date(saida.data + 'T00:00:00').toLocaleDateString('pt-BR');
  const valorFormatado = saida.valor.toLocaleString('pt-BR', {
    style: 'currency',
    currency: 'BRL'
  });
  
  const emojiCategoria = {
    'Aluguel': 'üè†', 'Energia': '‚ö°', 'Internet': 'üåê', '√Ågua': 'üíß',
    'Combust√≠vel': '‚õΩ', 'Material': 'üì¶', 'Transporte': 'üöó', 'Alimenta√ß√£o': 'üçΩÔ∏è',
    'Marketing': 'üì¢', 'Sa√∫de': 'üè•'
  };
  
  const emoji = emojiCategoria[saida.categoria] || 'üìä';
  
  // Emoji baseado no status
  let statusEmoji = 'üìä';
  let statusTexto = 'Atual';
  
  if (saida.statusSaida === 'vencida') {
    statusEmoji = '‚ö†Ô∏è';
    statusTexto = 'Vencida';
  } else if (saida.statusSaida === 'futura') {
    statusEmoji = 'üìÖ';
    statusTexto = 'Agendada';
  }
  
  let resposta = `‚úÖ *Sa√≠da ${statusTexto.toLowerCase()} registrada!*\n\n`;
  
  resposta += `üí∞ *Valor:* ${valorFormatado}\n`;
  resposta += `${emoji} *Centro de Custo:* ${saida.categoria}\n`;
  resposta += `üè™ *Loja:* ${saida.loja}\n`;
  resposta += `üìÖ *Data:* ${dataFormatada}\n`;
  resposta += `${statusEmoji} *Status:* ${statusTexto}\n`;
  resposta += `üí≥ *Pagamento:* ${saida.pago === "Sim" ? "Pago ‚úÖ" : "Pendente ‚è≥"}\n`;
  
  if (saida.recorrente === "Sim") {
    resposta += `üîÑ *Recorr√™ncia:* ${saida.tipoRecorrencia}\n`;
  }
  
  resposta += `\nü§ñ *Processado pela IA Melhorada*`;
  
  return resposta;
}

console.log('‚úÖ IA Melhorada implementada!');
console.log('üè∑Ô∏è Sistema de cria√ß√£o de centros de custo ativo');
console.log('üìä Classifica√ß√£o de status implementada');
console.log('üîÑ Recorr√™ncia apenas quando mencionada');